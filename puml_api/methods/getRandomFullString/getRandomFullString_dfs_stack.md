## Анализ временной сложности алгоритма `getRandomFullString`

Данный:
- `N`: количество узлов в Trie.
- `b`: коэффициент ветвления или максимальное количество дочерних узлов для узла.
- `L`: параметр длины как требуемая длина строки.
- `w`: средняя длина слова в Trie.`
`
### Инициализация:
- Инициализация стека постоянна: \( O(1) \)

### Основной цикл:
- Цикл while в худшем случае посещает каждый узел один раз: \( O(N) \)

   - операция `pop` занимает постоянное время: \( O(1) \)
   - Проверка и добавление слов: `wordsArray.join(separator)` может происходить на каждой итерации: \( O(L/w) \)
   - Перетасовка дочерних элементов: `shuffleArray` занимает время \( O(b) \) для каждого узла.
   - Помещение в стек: добавление дочерних узлов `b` занимает \( O(b) \) времени на каждой итерации.

### Упрощенная временная сложность для наихудшего случая:

$$ O(N \cdot (L/w + b)) $$

При этом предполагается, что сравнение и копирование строк выполняются за постоянное время, чего не происходит в случае длинных строк. Однако, поскольку эти операции незначительны по сравнению с общим количеством узлов и глубиной дерева, мы упрощаем общую сложность до:

$$ O(N \cdot b) $$

Это упрощение особенно справедливо для больших N, где общее количество операций приближается к числу узлов, умноженному на коэффициент ветвления.